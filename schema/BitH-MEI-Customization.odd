<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?><?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<TEI xmlns:rng="http://relaxng.org/ns/structure/1.0"
   xmlns:sch="http://purl.oclc.org/dsdl/schematron"
   xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://www.tei-c.org/ns/1.0">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>Beethoven in the House ODD Customization</title>
            <respStmt>
               <resp>Authored by</resp>
               <name xml:id="LR">Lisa Rosendahl</name>
               <name xml:id="MS">Mark Saccomano</name>
               <name xml:id="JK">Johannes Kepper</name>
            </respStmt>
            <respStmt>
               <resp>Project Team of Beethoven in the House</resp>
               <name xml:id="bithTeam_ch" role="res" from="2021-10" to="2021-11">Christin Heitmann</name>
               <name xml:id="bithTeam_dl" role="res"
                  ref="https://orcid.org/0000-0003-4151-0499">David Lewis</name>
               <name xml:id="bithTeam_lr" role="res"
                  ref="https://orcid.org/0000-0002-4826-4553">Lisa Rosendahl</name>
               <name xml:id="bithTeam_ms" role="res"
                  ref="https://orcid.org/0000-0002-4635-7684">Mark Saccomano</name>
               <name xml:id="bithTeam_es" role="res"
                  ref="https://orcid.org/0009-0004-0272-8377">Elisabete Shibata</name>
               <name xml:id="bithTeam_ah" role="led"
                  ref="https://orcid.org/0000-0003-2663-0003">Andrew Hankinson</name>
               <name xml:id="bithTeam_jk" role="led"
                  ref="https://orcid.org/0000-0003-4891-260X">Johannes Kepper</name>
               <name xml:id="bithTeam_kp" role="led"
                  ref="https://orcid.org/0000-0002-1668-6540">Kevin Page</name>
               <name xml:id="bithTeam_cs" role="led">Christine Siegert</name>
               <name xml:id="bithTeam_fs" role="ctb" from="2020-10" to="2020-12">Fabian Schmidt</name>
            </respStmt>
            <funder>
               <ident type="projectNumber">429039809</ident>
               <name ref="viaf-of-dfg">Deutsche Forschungsgemeinschaft
                  (DFG)</name>
            </funder>
            <funder>
               <ident type="projectNumber">AH/T01279X/1</ident>
               <name ref="viaf-of-ahrc">Arts and Humanities Research Council
                  (AHRC)</name>
            </funder>
         </titleStmt>
         <publicationStmt>
            <publisher>Beethoven in the House
               <add>The project "Beethoven in the House: Digital Studies of Domestic Music Arrangements"
                     investigated domestic music arrangements of the 19th Century through two
                     complementary studies, a digital research environment developed
                     alongside the studies, and the innovative application of digital musicology
                     methods within this environment. Beethoven-Haus Bonn, Oxford e-Research Center, RISM Digital,
                     and Paderborn University partnered for this project.
                     
                     Performance of music in the home was the means by which most works were received
                     before the advent of audio recordings and broadcasts, yet the notation sources
                     that form our primary record of this culture had not been the subject of
                     comprehensive or methodical study. Choices made by arrangers adapting music for
                     domestic consumption-of instrumentation, abbreviation, or simplification-reflect
                     the musical life of the 19th-century, and can inform our understanding alongside
                     contemporary accounts such as newspapers, adverts, and diaries.
                     
                     By analysing the choices made by arrangers adapting music for domestic consumption,
                     such as instrumentation, abbreviation, or simplification, this project shed light on
                     the musical life of the 19th century and can inform our understanding alongside contemporary
                     accounts such as newspapers, adverts, and diaries. The project's studies surveyed
                     Steiner editions of Beethoven's 7th and 8th Symphonies and Wellingtons Sieg, as well
                     as a larger sample of lesser-known scores, collating emergent
                     indicators of arrangers' motivations within a narrative of the domestic market â€“ the music
                     industry of its day.
                     
                     The project developed new methods for including selective approaches to encodings, utilising 
                     Optical Music Recognition and Linked Data to find and structure new knowledge. The project's 
                     findings provide new insights into the domestic music culture of the 19th Century. 
                     For more information and to view our publications, please visit the project website at
                     https://domestic-beethoven.eu. The project ran from 2020 to 2023 and was jointly funded by 
                     DFG and AHRC.</add>
            </publisher>
            <date when="2023"/>
            <availability>
               <licence target="http://creativecommons.org/licenses/by-sa/4.0/">
                  Creative Commons Attribution-ShareAlike 4.0 International </licence>
            </availability>
         </publicationStmt>
         <sourceDesc>
            <p>Original work by the Beethoven in the House project</p>
         </sourceDesc>
      </fileDesc>
      <revisionDesc>
         <change n="1" when="2021-05-17" who="#MS #JK">
            <desc>Initial setup of the ODD.</desc>
         </change>
         <change n="2" when="2023-02-14" who="#LR #MS #JK">
            <desc>Final adjustments to the ODD.</desc>
         </change>
      </revisionDesc>
   </teiHeader>
   <text>
      <body>
         <schemaSpec ident="mei" ns="http://www.music-encoding.org/ns/mei" prefix="mei_"
            start="mei">
            <!-- Declare MEI and XLink namespaces for use in Schematron -->
            <constraintSpec ident="set_ns" scheme="isoschematron" mode="add">
               <constraint>
                  <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="mei"
                     uri="http://www.music-encoding.org/ns/mei"/>
                  <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="xlink"
                     uri="http://www.w3.org/1999/xlink"/>
               </constraint>
            </constraintSpec>
            <!-- Include all modules -->
            <moduleRef key="MEI"/>
            <moduleRef key="MEI.analytical"/>
            <moduleRef key="MEI.cmn"
               except="beamSpan bend bracketSpan breath meterSigGrp mNum tupletSpan"/>
            <moduleRef key="MEI.cmnOrnaments"/>
            <moduleRef key="MEI.drama" except="sp"/>
            <moduleRef key="MEI.externalsymbols"/>
            <moduleRef key="MEI.facsimile"/>
            <moduleRef key="MEI.figtable" except="fig figDesc table td th tr"/>
            <moduleRef key="MEI.fingering"/>
            <moduleRef key="MEI.frbr"/>
            <moduleRef key="MEI.gestural"/>
            <moduleRef key="MEI.harmony" except="chordDef chordMember chordTable"/>
            <moduleRef key="MEI.header"
               except="componentList acquisition altId attUsage audience bifolium byline captureMode carrierForm category catRel classDecls classification condition contentItem contents context cutout editionStmt exhibHist extMeta fileChar fingerprint foliaDesc folium hand handList history incipCode incipText inscription key mensuration meter namespace notesStmt otherChar patch perfDuration physDesc physMedium playingSpeed price provenance segmentation soundChan specRepro stdVals sysReq tagsDecl tagUsage taxonomy termList trackConfig treatHist treatSched useRestrict watermark"/>
            <moduleRef key="MEI.lyrics"/>
            <moduleRef key="MEI.namesdates"
               except="addName bloc country district famName foreName genName geogFeat nameLink periodName postBox postCode region roleName settlement street styleName"/>
            <moduleRef key="MEI.shared"
               except="actor address addrLine ambitus ambNote analytic annot author barLine caption castGrp castItem cb castList colLayout contributor custos depth dim dimensions distributor div dot edition event eventList expansion extent genre group height imprint incip keyAccid lb lg librettist monogr pad pgDesc pgFoot pgFoot2 pgHead pgHead2 phrase recipient relatedItem role roleDesc speaker sponsor stack term textLang titlePage titlePart width"/>
            <moduleRef key="MEI.usersymbols"
               except="anchoredText curve line mapping propName propValue"/>
            <moduleRef key="MEI.visual"/>
            <!-- Include SVG -->
            <moduleRef url="https://www.tei-c.org/release/xml/tei/custom/schema/relaxng/svg11.rng"
               prefix="svg_">
               <content>
                  <rng:define name="mei_model.graphicLike" combine="choice">
                     <rng:ref name="svg_svg"/>
                  </rng:define>
               </content>
            </moduleRef>
            <classSpec type="atts" ident="att.sp.log" mode="delete"/>
            <classSpec type="atts" ident="att.bifoliumSurfaces" mode="delete"/>
            <classSpec type="atts" ident="att.foliumSurfaces" mode="delete"/>
            <classSpec type="atts" ident="att.anchoredText.log" mode="delete"/>
            <classSpec type="atts" ident="att.curve.log" mode="delete"/>
            <classSpec type="atts" ident="att.line.log" mode="delete"/>
            <classSpec type="atts" ident="att.chordDef.log" mode="delete"/>
            <classSpec type="atts" ident="att.chordMember.log" mode="delete"/>
            <classSpec type="atts" ident="att.f.log" mode="delete"/>

            <macroSpec ident="macro.metaLike.page" module="MEI.shared" mode="delete"/>

            <elementSpec ident="mei" module="MEI.shared" mode="change">
               <!-- All BitH Schematron rules are gathered here for better orientation. -->
               <constraintSpec ident="check-mei-id" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:mei">
                        <sch:assert test="@xml:id">An mei file must have an id</sch:assert>
                     </sch:rule>
                     <!-- API rules -->
                     <sch:rule context="mei:meiHead">
                        <sch:assert test="mei:workList[count(mei:work) = 1]">
                           There needs to be a workList, with exactly one work in there.
                        </sch:assert>
                        <sch:assert test="mei:manifestationList[count(mei:manifestation) = 1]">
                           There needs to be a manifestationList, with exactly one manifestation in there.
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:fileDesc">
                        <sch:assert test="./mei:titleStmt/mei:title[@type='desc']">
                           Every fileDesc needs a descriptive title (./mei:title[@type='desc']/text()).
                        </sch:assert>
                        <sch:assert test="not(./mei:composer/element()) and not(./mei:composer/@*)">
                           The composer is for display only and should just contain plain text.
                        </sch:assert>
                        <sch:assert test="not(./mei:arranger/element()) and not(./mei:arranger/@*)">
                           The arranger is for display only and should just contain plain text.
                        </sch:assert>
                        <sch:assert test="not(./mei:lyricist/element()) and not(./mei:lyricist/@*)">
                           The lyricist is for display only and should just contain plain text.
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:persName[ancestor::mei:seriesStmt]">
                        <sch:assert test="@xml:id and starts-with(@xml:id, 'bithTeam_') and string-length(@xml:id) = 11">
                           Every project member needs an xml:id starting with 'bithTeam_', followed by two initials.
                        </sch:assert>
                        <sch:assert test="@role">Every project team member should have a @role.</sch:assert>
                        <!-- <sch:assert test="@auth.uri" role="warning">Every project team member should have an @auth.uri.</sch:assert> -->
                     </sch:rule>
                     
                     <!-- for ensuring that the fileDesc is complete -->
                     <sch:rule context="mei:fileDesc">
                        <sch:assert test="mei:seriesStmt">
                           The fileDesc must contain a seriesStmt.
                        </sch:assert>
                        <sch:assert test="mei:sourceDesc/mei:source">
                           The fileDesc must contain a sourceDesc that contains a source.
                        </sch:assert>
                        <sch:assert test="mei:pubStmt/mei:date and mei:pubStmt/mei:availability">
                           The fileDesc must contain a pubStmt that contains a date and an availability.
                        </sch:assert>
                     </sch:rule>
                     
                     <sch:rule context="mei:source">
                        <sch:assert test="substring(@sameas,2) = ancestor::mei:meiHead//mei:manifestation/@xml:id">
                           The source of the encoding must be one of the manifestations.
                        </sch:assert>
                     </sch:rule>
                     
                     <!-- rules for checking people involved in the file -->
                     <sch:rule context="mei:persName[ancestor::mei:fileDesc/mei:titleStmt/mei:respStmt]">
                        <sch:assert test="(not(@xml:id) and @sameas and not(./text())) or (@xml:id and not(@sameas) and ./text())">
                           People involved in the creation of a file must either have _no_ @xml:id, _no_ textual content, and a @sameas reference to a project member (in seriesStmt), or: 
                           have an @xml:id, have a name spelled out here, and no @sameas reference to team members.
                        </sch:assert>
                        <sch:assert test="@role">A @role should be specified. Suggested values include trc (transcriber) and mrk (markup editor).</sch:assert>
                        <sch:let name="teamMembers"
                           value="./ancestor::mei:fileDesc//mei:seriesStmt//mei:persName/@xml:id"/>
                        <sch:assert test="not(@sameas) or substring(@sameas, 2) = $teamMembers">@sameas has to reference a project team member from .//mei:seriesStmt.</sch:assert>
                     </sch:rule>
                     
                     <!-- rules for dates and places -->
                     <sch:rule context="mei:geogName">
                        <sch:assert test="@auth.uri or (string-length(normalize-space(text())) gt 0)">
                           A geographical name needs either an authority reference, or a specified place name.
                        </sch:assert>
                     </sch:rule>
                     
                     <!--dates -->
                     <sch:rule context="mei:date">
                        <sch:assert test="@isodate or @notbefore or @notafter or (@startdate and @enddate)">
                           A date needs either an @isodate or a @startdate and an @enddate.
                        </sch:assert>    
                        <sch:assert test="not(@type)">
                           Dates shouldn't be defined by a @type.
                        </sch:assert>
                        <sch:assert test="not(node())">
                           Dates must be empty elements.
                        </sch:assert>
                     </sch:rule>
                  
                     <sch:rule context="@auth.uri">
                        <sch:assert test="string-length(normalize-space(.)) gt 0">
                           Every reference to an authority needs to be longer than zero.
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:rend">
                        <sch:report role="warning" test="@fontfam">fontfamily unnecessary and should be deleted</sch:report>
                     </sch:rule>
                     <sch:rule context="mei:dir">
                        <sch:report role="warning" test="mei:rend[2]">dir should only have 1 rend element</sch:report>
                     </sch:rule>
                     <sch:rule context="mei:tie">
                        <sch:assert test="@startid or @tstamp">A tie needs @startid</sch:assert>
                        <sch:assert test="@endid or @tstamp2">A tie needs @endid</sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>

            <elementSpec ident="work" module="MEI.frbr" mode="change">
               <!-- All BitH Schematron rules are gathered here for better orientation. -->
               <constraintSpec ident="check-works" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:work">
                        <sch:assert test="mei:title">A work must have a title</sch:assert>
                        <sch:assert test="@auth.uri"> Every work should have an auth.uri. </sch:assert>
                        <sch:assert test="./mei:identifier[@type='opusNumber']"> Every work should
                           have an identifier with @type="opusNumber". </sch:assert>
                        <sch:assert test="./mei:title[@type='uniform']"> Every work should have a
                           title with @type="uniform". </sch:assert>
                        <sch:assert test="./mei:title[@type='abbreviated']"> Every work should have
                           a short title with @type="abbreviated". </sch:assert>
                        <sch:assert test="./mei:composer/mei:persName[@auth.uri]"> Every work should
                           have a composer, which needs to be encoded as persName with @auth.uri. </sch:assert>
                        <sch:assert test="./mei:creation/mei:date"> Every work should have a
                           creation date. </sch:assert>
                        <sch:assert test="./mei:expressionList/mei:expression"> Every work needs an
                           expression. </sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>

            <elementSpec ident="manifestation" module="MEI.frbr" mode="change">
               <!-- All BitH Schematron rules are gathered here for better orientation. -->
               <constraintSpec ident="check-manifestations" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:manifestation">
                        <sch:assert
                           test="./mei:titleStmt/mei:title/text() and string-length(./mei:titleStmt/mei:title/text()) gt 0"
                           > Every manifestation should have a title. </sch:assert>
                        <sch:assert test="./mei:pubStmt"> Every manifestation needs a publication
                           statement. </sch:assert>
                        <sch:assert test="./mei:pubStmt/mei:pubPlace/mei:geogName"> Every
                           manifestation needs a publication place, expressed as a geogName. </sch:assert>
                        <sch:assert test="./mei:pubStmt/mei:date"> Every manifestation needs a
                           publication date. </sch:assert>
                        <sch:assert test="./mei:pubStmt/mei:publisher/mei:corpName"> Every
                           manifestation should have a publisher with a corpName. </sch:assert>
                        <sch:assert test=".//mei:item"> Every manifestations needs at least one
                           item. </sch:assert> <sch:let name="expressionLink"
                           value="./mei:relationList/mei:relation[@rel='isEmbodimentOf']"/>
                        <sch:let name="expressionIDs"
                           value="./ancestor::mei:meiHead//mei:expression/@xml:id"/>
                        <sch:assert test="exists($expressionLink)"> Every manifestation needs a
                           relation to an expression. </sch:assert>
                        <sch:assert test="$expressionLink/substring(@target,2) = $expressionIDs">
                           Every manifestation needs to relate to an existing expression xml:id.
                           mei:manifestation/mei:relationList/mei:relation/@target seems broken.
                        </sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>

            <elementSpec ident="expression" module="MEI.frbr" mode="change">
               <!-- All BitH Schematron rules for Expression are gathered here for better orientation. -->
               <constraintSpec ident="check-expressions" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:expression">
                        <sch:assert test="@xml:id"> Every expression needs an xml:id. </sch:assert>
                        <sch:assert test="./mei:identifier[@type='genre']/@auth.uri"> Every
                           expression needs a genre reference
                           (./mei:identifier[@type='genre']/@auth.uri). </sch:assert>
                        <sch:assert test="./mei:title[@type='desc']/text()"> Every expression needs
                           a descriptive title (./mei:title[@type='desc']/text()). </sch:assert>
                        <sch:assert test="./mei:perfMedium/mei:perfResList/mei:perfRes/@auth.uri">
                           Every expression needs a perfResList/perfRes/@auth.uri. </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:expression/mei:arranger">
                        <sch:assert test="mei:persName">
                           The arranger element in the expression should have a persName.
                        </sch:assert>
                        <sch:assert test="not(some $text in .//text() satisfies (contains(lower-case($text),'anon') or contains(lower-case($text),'unknown')))" role="warning">
                           Unknown or anonymous arrangers should not be provided in the file.
                        </sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>
            
            <elementSpec ident="item" module="MEI.frbr" mode="change">
               <!-- All BitH Schematron rules for Item are gathered here for better orientation. -->
               <constraintSpec ident="check-items" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:item">
                        <sch:assert test="./@xml:id">
                           Every item should have an xml:id.
                        </sch:assert>
                        <sch:assert test="./mei:physLoc">
                           Every item should have a physLoc.
                        </sch:assert>
                        <sch:assert test="./mei:physLoc/mei:repository[string-length(normalize-space(text())) gt 0]">
                           Every physLoc should have a repository.
                        </sch:assert>
                        <sch:assert test="./mei:physLoc/mei:identifier[string-length(normalize-space(text())) gt 0]">
                           Every physLoc should have an identifier.
                        </sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>
            <elementSpec ident="facsimile" module="MEI.facsimile" mode="change">
               <constraintSpec ident="check-facsimiles" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:facsimile">
                        <sch:assert test="./mei:surface">
                           Every facsimile needs at least one surface element
                        </sch:assert>
                     </sch:rule>    
                     <sch:rule context="mei:surface">
                        <sch:assert test="count(./mei:graphic[@type='facsimile']) = 1">
                           Every surface needs one and only one graphic element @type=facsimile 
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:graphic">
                        <sch:assert test="@target and string-length(@target) gt 0">
                           Every graphic needs a @target
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:zone">
                        <sch:let name="facsrefs" value="ancestor::mei:mei//@facs"/>
                        <sch:assert test="'#' || @xml:id = $facsrefs">
                           The zone is not referenced by any @facs attribute.
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="@facs[not(parent::mei:pb)]">
                        <sch:let name="zoneIDs" value="ancestor::mei:mei//mei:zone/@xml:id"/>
                        <sch:assert test="substring(.,2) = $zoneIDs">
                           Every @facs must reference a zone.
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:pb/@facs">
                        <sch:let name="surfaceIDs" value="ancestor::mei:mei//mei:surface/@xml:id"/>
                        <sch:assert test="substring(.,2) = $surfaceIDs">
                           Every @facs on pb must reference a surface.
                        </sch:assert>
                     </sch:rule>
                  </constraint>                
               </constraintSpec>
            </elementSpec>
            
         </schemaSpec>
      </body>
   </text>
</TEI>
