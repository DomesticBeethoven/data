<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?><?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<TEI xmlns:rng="http://relaxng.org/ns/structure/1.0"
   xmlns:sch="http://purl.oclc.org/dsdl/schematron"
   xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://www.tei-c.org/ns/1.0">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>Beethoven in the House ODD Customization</title>
            <respStmt>
               <resp>Authored by</resp>
               <name xml:id="LR">Lisa Rosendahl</name>
               <name xml:id="MS">Mark Saccomano</name>
               <name xml:id="JK">Johannes Kepper</name>
            </respStmt>
         </titleStmt>
         <publicationStmt>
            <p/>
         </publicationStmt>
         <sourceDesc>
            <p/>
         </sourceDesc>
      </fileDesc>
      <revisionDesc>
         <change n="1" when="2021-05-17" who="#MS #JK">
            <desc>Initial setup of the ODD.</desc>
         </change>
         <change n="2" when="2023-02-14" who="#LR #MS #JK">
            <desc>Final adjustments to the ODD.</desc>
         </change>
      </revisionDesc>
   </teiHeader>
   <text>
      <front>
         <divGen type="toc"/>
      </front>
      <body>
         <!-- Limit the set of possible start elements -->
         <schemaSpec ident="mei" ns="http://www.music-encoding.org/ns/mei" prefix="mei_"
            start="mei meiHead meiCorpus music">
            <!-- Declare MEI and XLink namespaces for use in Schematron -->
            <constraintSpec ident="set_ns" scheme="isoschematron" mode="add">
               <constraint>
                  <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="mei"
                     uri="http://www.music-encoding.org/ns/mei"/>
                  <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="xlink"
                     uri="http://www.w3.org/1999/xlink"/>
               </constraint>
            </constraintSpec>
            <!-- Include all modules -->
            <moduleRef key="MEI"/>
            <moduleRef key="MEI.analytical"/>
            <moduleRef key="MEI.cmn"
               except="beamSpan bend bracketSpan breath meterSigGrp mNum tupletSpan"/>
            <moduleRef key="MEI.cmnOrnaments"/>
            <moduleRef key="MEI.drama" except="sp"/>
            <moduleRef key="MEI.externalsymbols"/>
            <moduleRef key="MEI.facsimile"/>
            <moduleRef key="MEI.figtable" except="fig figDesc table td th tr"/>
            <moduleRef key="MEI.fingering"/>
            <moduleRef key="MEI.frbr"/>
            <moduleRef key="MEI.gestural"/>
            <moduleRef key="MEI.header"
               except="componentList acquisition altId attUsage audience bifolium byline captureMode carrierForm category catRel classDecls classification condition contentItem contents context cutout editionStmt exhibHist extMeta fileChar fingerprint foliaDesc folium hand handList history incipCode incipText inscription key mensuration meter namespace notesStmt otherChar patch perfDuration physDesc physMedium playingSpeed price provenance segmentation soundChan specRepro stdVals sysReq tagsDecl tagUsage taxonomy termList trackConfig treatHist treatSched useRestrict watermark"/>
            <moduleRef key="MEI.lyrics"/>
            <moduleRef key="MEI.namesdates"
               except="addName bloc country district famName foreName genName geogFeat nameLink periodName postBox postCode region roleName settlement street styleName"/>
            <moduleRef key="MEI.shared"
               except="actor address addrLine ambitus ambNote analytic annot author barLine caption castGrp castItem cb castList colLayout contributor custos depth dim dimensions distributor div dot edition event eventList expansion extent genre group height imprint incip keyAccid lb lg librettist monogr num pad pgDesc pgFoot pgFoot2 pgHead pgHead2 phrase recipient relatedItem role roleDesc speaker sponsor stack term textLang titlePage titlePart width"/>
            <moduleRef key="MEI.usersymbols"
               except="anchoredText curve line mapping propName propValue"/>
            <moduleRef key="MEI.visual"/>
            <!-- Include SVG -->
            <moduleRef url="https://www.tei-c.org/release/xml/tei/custom/schema/relaxng/svg11.rng"
               prefix="svg_">
               <content>
                  <rng:define name="mei_model.graphicLike" combine="choice">
                     <rng:ref name="svg_svg"/>
                  </rng:define>
               </content>
            </moduleRef>
            <classSpec type="atts" ident="att.sp.log" mode="delete"/>
            <classSpec type="atts" ident="att.bifoliumSurfaces" mode="delete"/>
            <classSpec type="atts" ident="att.foliumSurfaces" mode="delete"/>
            <classSpec type="atts" ident="att.anchoredText.log" mode="delete"/>
            <classSpec type="atts" ident="att.curve.log" mode="delete"/>
            <classSpec type="atts" ident="att.line.log" mode="delete"/>

            <macroSpec ident="macro.metaLike.page" module="MEI.shared" mode="delete"/>

            <elementSpec ident="mei" module="MEI.shared" mode="change">
               <!-- All BitH Schematron rules are gathered here for better orientation. -->
               <constraintSpec ident="check-mei-id" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:mei">
                        <sch:assert test="@xml:id">An mei file must have an id</sch:assert>
                     </sch:rule>
                     <!-- API rules -->
                     <sch:rule context="mei:meiHead">
                        <sch:assert test="mei:workList[count(mei:work) = 1]">
                           There needs to be a workList, with exactly one work in there.
                        </sch:assert>
                        <sch:assert test="mei:manifestationList[count(mei:manifestation) = 1]">
                           There needs to be a manifestationList, with exactly one manifestation in there.
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:fileDesc">
                        <sch:assert test="./mei:titleStmt/mei:title[@type='desc']">
                           Every fileDesc needs a descriptive title (./mei:title[@type='desc']/text()).
                        </sch:assert>
                        <sch:assert test="not(./mei:composer/element()) and not(./mei:composer/@*)">
                           The composer is for display only and should just contain plain text.
                        </sch:assert>
                        <sch:assert test="not(./mei:arranger/element()) and not(./mei:arranger/@*)">
                           The arranger is for display only and should just contain plain text.
                        </sch:assert>
                        <sch:assert test="not(./mei:lyricist/element()) and not(./mei:lyricist/@*)">
                           The lyricist is for display only and should just contain plain text.
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:persName[ancestor::mei:seriesStmt]">
                        <sch:assert test="@xml:id and starts-with(@xml:id, 'bithTeam_') and string-length(@xml:id) = 11">
                           Every project member needs an xml:id starting with 'bithTeam_', followed by two initials.
                        </sch:assert>
                        <sch:assert test="@role">Every project team member should have a @role.</sch:assert>
                        <sch:assert test="@auth.uri" role="warning">Every project team member should have an @auth.uri.</sch:assert>
                     </sch:rule>
                     
                     <!-- for ensuring that the fileDesc is complete -->
                     <sch:rule context="mei:fileDesc">
                        <sch:assert test="mei:seriesStmt">
                           The fileDesc must contain a seriesStmt.
                        </sch:assert>
                        <sch:assert test="mei:sourceDesc/mei:source">
                           The fileDesc must contain a sourceDesc that contains a source.
                        </sch:assert>
                        <sch:assert test="mei:pubStmt/mei:date and mei:pubStmt/mei:availability">
                           The fileDesc must contain a pubStmt that contains a date and an availability.
                        </sch:assert>
                     </sch:rule>
                     
                     <sch:rule context="mei:source">
                        <sch:assert test="substring(@sameas,2) = ancestor::mei:meiHead//mei:manifestation/@xml:id">
                           The source of the encoding must be one of the manifestations.
                        </sch:assert>
                     </sch:rule>
                     
                     <!-- rules for checking people involved in the file -->
                     <sch:rule context="mei:persName[ancestor::mei:fileDesc/mei:titleStmt/mei:respStmt]">
                        <sch:assert test="(not(@xml:id) and @sameas and not(./text())) or (@xml:id and not(@sameas) and ./text())">
                           People involved in the creation of a file must either have _no_ @xml:id, _no_ textual content, and a @sameas reference to a project member (in seriesStmt), or: 
                           have an @xml:id, have a name spelled out here, and no @sameas reference to team members.
                        </sch:assert>
                        <sch:assert test="@role">A @role should be specified. Suggested values include trc (transcriber) and mrk (markup editor).</sch:assert>
                        <sch:let name="teamMembers"
                           value="./ancestor::mei:fileDesc//mei:seriesStmt//mei:persName/@xml:id"/>
                        <sch:assert test="not(@sameas) or substring(@sameas, 2) = $teamMembers">@sameas has to reference a project team member from .//mei:seriesStmt.</sch:assert>
                     </sch:rule>
                     
                     <!-- rules for dates and places -->
                     <sch:rule context="mei:geogName">
                        <sch:assert test="@auth.uri or (string-length(normalize-space(text())) gt 0)">
                           A geographical name needs either an authority reference, or a specified place name.
                        </sch:assert>
                     </sch:rule>
                     
                     <!--dates -->
                     <sch:rule context="mei:date">
                        <sch:assert test="@isodate or (@startdate and @enddate)">
                           A date needs either an @isodate or a @startdate and an @enddate.
                        </sch:assert>    
                        <sch:assert test="not(@type)">
                           Dates shouldn't be defined by a @type.
                        </sch:assert>
                        <sch:assert test="not(node())">
                           Dates must be empty elements.
                        </sch:assert>
                     </sch:rule>
                  
                     <sch:rule context="@auth.uri">
                        <sch:assert test="string-length(normalize-space(.)) gt 0">
                           Every reference to an authority needs to be longer than zero.
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:rend">
                        <sch:report role="warning" test="@fontfam">fontfamily unnecessary and should be deleted</sch:report>
                     </sch:rule>
                     <sch:rule context="mei:dir">
                        <sch:report role="warning" test="mei:rend[2]">dir should only have 1 rend element</sch:report>
                     </sch:rule>
                     <sch:rule context="mei:tie">
                        <sch:assert test="@startid or @tstamp">A tie needs @startid</sch:assert>
                        <sch:assert test="@endid or @tstamp2">A tie needs @endid</sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>

            <elementSpec ident="work" module="MEI.frbr" mode="change">
               <!-- All BitH Schematron rules are gathered here for better orientation. -->
               <constraintSpec ident="check-works" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:work">
                        <sch:assert test="mei:title">A work must have a title</sch:assert>
                        <sch:assert test="@auth.uri"> Every work should have an auth.uri. </sch:assert>
                        <sch:assert test="./mei:identifier[@type='opusNumber']"> Every work should
                           have an identifier with @type="opusNumber". </sch:assert>
                        <sch:assert test="./mei:title[@type='uniform']"> Every work should have a
                           title with @type="uniform". </sch:assert>
                        <sch:assert test="./mei:title[@type='abbreviated']"> Every work should have
                           a short title with @type="abbreviated". </sch:assert>
                        <sch:assert test="./mei:composer/mei:persName[@auth.uri]"> Every work should
                           have a composer, which needs to be encoded as persName with @auth.uri. </sch:assert>
                        <sch:assert test="./mei:creation/mei:date"> Every work should have a
                           creation date. </sch:assert>
                        <sch:assert test="./mei:expressionList/mei:expression"> Every work needs an
                           expression. </sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>

            <elementSpec ident="manifestation" module="MEI.frbr" mode="change">
               <!-- All BitH Schematron rules are gathered here for better orientation. -->
               <constraintSpec ident="check-manifestations" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:manifestation">
                        <sch:assert
                           test="./mei:titleStmt/mei:title/text() and string-length(./mei:titleStmt/mei:title/text()) gt 0"
                           > Every manifestation should have a title. </sch:assert>
                        <sch:assert test="./mei:pubStmt"> Every manifestation needs a publication
                           statement. </sch:assert>
                        <sch:assert test="./mei:pubStmt/mei:pubPlace/mei:geogName"> Every
                           manifestation needs a publication place, expressed as a geogName. </sch:assert>
                        <sch:assert test="./mei:pubStmt/mei:date"> Every manifestation needs a
                           publication date. </sch:assert>
                        <sch:assert test="./mei:pubStmt/mei:publisher/mei:corpName"> Every
                           manifestation should have a publisher with a corpName. </sch:assert>
                        <sch:assert test=".//mei:item"> Every manifestations needs at least one
                           item. </sch:assert> <sch:let name="expressionLink"
                           value="./mei:relationList/mei:relation[@rel='isEmbodimentOf']"/>
                        <sch:let name="expressionIDs"
                           value="./ancestor::mei:meiHead//mei:expression/@xml:id"/>
                        <sch:assert test="exists($expressionLink)"> Every manifestation needs a
                           relation to an expression. </sch:assert>
                        <sch:assert test="$expressionLink/substring(@target,2) = $expressionIDs">
                           Every manifestation needs to relate to an existing expression xml:id.
                           mei:manifestation/mei:relationList/mei:relation/@target seems broken.
                        </sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>

            <elementSpec ident="expression" module="MEI.frbr" mode="change">
               <!-- All BitH Schematron rules for Expression are gathered here for better orientation. -->
               <constraintSpec ident="check-expressions" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:expression">
                        <sch:assert test="@xml:id"> Every expression needs an xml:id. </sch:assert>
                        <sch:assert test="./mei:identifier[@type='genre']/@auth.uri"> Every
                           expression needs a genre reference
                           (./mei:identifier[@type='genre']/@auth.uri). </sch:assert>
                        <sch:assert test="./mei:title[@type='desc']/text()"> Every expression needs
                           a descriptive title (./mei:title[@type='desc']/text()). </sch:assert>
                        <sch:assert test="./mei:perfMedium/mei:perfResList/mei:perfRes/@auth.uri">
                           Every expression needs a perfResList/perfRes/@auth.uri. </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:expression/mei:arranger">
                        <sch:assert test="mei:persName">
                           The arranger element in the expression should have a persName.
                        </sch:assert>
                        <sch:assert test="not(some $text in .//text() satisfies (contains(lower-case($text),'anon') or contains(lower-case($text),'unknown')))" role="warning">
                           Unknown or anonymous arrangers should not be provided in the file.
                        </sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>
            
            <elementSpec ident="item" module="MEI.frbr" mode="change">
               <!-- All BitH Schematron rules for Item are gathered here for better orientation. -->
               <constraintSpec ident="check-items" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:item">
                        <sch:assert test="./@xml:id">
                           Every item should have an xml:id.
                        </sch:assert>
                        <sch:assert test="./mei:physLoc">
                           Every item should have a physLoc.
                        </sch:assert>
                        <sch:assert test="./mei:physLoc/mei:repository[string-length(normalize-space(text())) gt 0]">
                           Every physLoc should have a repository.
                        </sch:assert>
                        <sch:assert test="./mei:physLoc/mei:identifier[string-length(normalize-space(text())) gt 0]">
                           Every physLoc should have an identifier.
                        </sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>
            <elementSpec ident="facsimile" module="MEI.facsimile" mode="change">
               <constraintSpec ident="check-facsimiles" scheme="isoschematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:facsimile">
                        <sch:assert test="./mei:surface">
                           Every facsimile needs at least one surface element
                        </sch:assert>
                     </sch:rule>    
                     <sch:rule context="mei:surface">
                        <sch:assert test="count(./mei:graphic[@type='facsimile']) = 1">
                           Every surface needs one and only one graphic element @type=facsimile 
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:graphic">
                        <sch:assert test="@target and string-length(@target) gt 0">
                           Every graphic needs a @target
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:zone">
                        <sch:let name="facsrefs" value="ancestor::mei:mei//@facs"/>
                        <sch:assert test="'#' || @xml:id = $facsrefs">
                           The zone is not referenced by any @facs attribute.
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="@facs[not(parent::mei:pb)]">
                        <sch:let name="zoneIDs" value="ancestor::mei:mei//mei:zone/@xml:id"/>
                        <sch:assert test="substring(.,2) = $zoneIDs">
                           Every @facs must reference a zone.
                        </sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:pb/@facs">
                        <sch:let name="surfaceIDs" value="ancestor::mei:mei//mei:surface/@xml:id"/>
                        <sch:assert test="substring(.,2) = $surfaceIDs">
                           Every @facs on pb must reference a surface.
                        </sch:assert>
                     </sch:rule>
                  </constraint>                
               </constraintSpec>
            </elementSpec>
            
         </schemaSpec>
      </body>
   </text>
</TEI>
